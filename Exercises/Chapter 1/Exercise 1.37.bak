#lang racket/base
;; exercise 1.37a(i)
(define (cont-frac n d k)
  ;; cont-frac procedure using recurrence relation
  (define (cont-frac-iter i)
    (define (h i)
      (cond ((= i 0) 0)
            ((= i 1) 1)
            (else (+ (*
                      (d i)
                      (h (- i 1)))
                     (*
                      (n 1)
                      (h (- i 2)))))))
    (define (r i)
      (cond ((= i 0) 1)
            ((= i (- 1)) 0)
            (else (+ (*
                      (d i)
                      (r (- i 1)))
                     (*
                      (n i)
                      (r (- i 2)))))))
    
    (define (final i)
      (/ (* (h i) (n i))
         (r i)))
    
    (final i)

    )
 
  (cont-frac-iter k)
  )

;; Test
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           11)

;; exercise 1.37a(ii)

(define (new-cont-frac n d k)
  (define (recursive i)
    (cond ((= i k) (/ (n k) (d k)))
          (else (/ (n i)
                   (+ (d i)
                      (recursive (+ i 1)))))))
  ;(trace recursive)
  (recursive 1))

;(new-cont-frac (lambda (i) 1.0)
 ;              (lambda (i) 1.0)
  ;             13)

;; exercise 1.37b
(define (cont-frac-iter n d k)
  (define (iter i result)
    (if (= i 0)
        result
        (iter
         (- i 1)
         (/ (n i)
                 (+ (d i) result))
         )))
  (iter k 0.0))

; (define (cont-frac-iter n d k) 
 ;  (define (frac-iter i result) 
  ;   (if (= i k) 
   ;      result 
    ;     (frac-iter (+ i 1) (/ (n (- k i)) (+ (d (- k i)) result))))) 
 ;  (frac-iter 0 0.0)) 
  
(define (returnTwoMul n)
  (define (isTwoMul? n)
    (= (remainder (- n 2) 3) 0))
  (cond ((isTwoMul? n) (* 2 (+ 1 (/ (- n 2) 3))))
        (else 1)))

;(new-cont-frac (lambda (i) 1.0)
 ;              (lambda (i) (returnTwoMul i))
  ;             11)